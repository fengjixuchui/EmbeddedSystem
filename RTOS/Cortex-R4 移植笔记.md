# Cortex-R4 移植笔记

本周主要是进行一款 Cortex-R 芯片的移植工作，该芯片有如下特点：

- 属于 Cortex-R 内核
- 芯片默认运行于大端模式
- 有 3M flash 和 256K ram
- R4 内核的寄存器组看起来与 Cortex-A 系列一致，同样拥有多种运行时状态和相应的 bank 寄存器组
- 中断系统与先前接触的 STM32 NVIC 和 ZYNQ 的 GIC 都不同，使用的是一种 VIM（Vectored Interrupt Manager (VIM) Module ） 的中断管理器，支持硬件中断跳转（系统提供的一种快速中断响应方式）和软件查表跳转两种方式，其中软件查表方式和我们先前在 Cortex-A 系列中中断的处理方式相似

#### 大端系统的处理

在先前接触到的大部分 CPU，都基于 arm 内核，大多都运行在小端模式，很少遇到运行于大端模式的 CPU，而目前 RTT 中的移植代码，大部分也默认按照小端模式来处理。由于本次移植需要处理的是大端模式的 CPU，因此在移植的过程中遇到了一些奇怪的现象。

在 RTT 操作系统中，当需要进行第一次线程切换前，需要将系统切换到 SVC 模式，然后执行如下代码：

```asm
    LDMIA   sp!, {r4}           ; pop new task cpsr to spsr
    MSR     spsr_cxsf, r4
    ; pop new task r0-r12, lr & pc, copy spsr to cpsr
    LDMIA   sp!, {r0-r12, lr, pc}^ 
```

这段代码将会从目标线程的栈中读出 CPSR 的值，存入到 SPSR 寄存器中，然后跳转到目标线程的执行代码中运行，跳转的过程中，最后一条命令会自动拷贝 SPSR 的值到目标线程环境下的 CPSR 寄存器中，而 CPSR 寄存器中保存着 CPU 的各种运行状态，这其中也包括了 CPU 是以大端模式还是以小端模式读取数据。

在 RTT 先前的 Cortex-A 系列的移植中，默认都配置成了小端模式，而这次，CPU 运行在大端模式下，一旦 CPU 的大小端模式被改变，很快就会出现莫名其妙的内存访问错误，原因是 CPU 会以小端数据的解析方式来解析大端数据。

#### SYSTEM 模式不会出错

在处理该问题的过程中还有另外一个现象，那就是如果在跳转前不切换到 SVC 模式，系统就不会崩溃，此时系统处于 SYSTEM 模式，该模式是调用该芯片的 HAL 库进行系统初始化后默认的状态。

造成这种情况的原因是，当系统处于 SYSTEM 模式下，这种状态没有 CPSR 和 SPSR 寄存器，如果进行访问操作，会出现未知状态，也就是说 `MSR     spsr_cxsf, r4` 这条指令是无效的，不会将相关的状态存入 SPSR 寄存器，系统也就不会切换到小端状态工作。