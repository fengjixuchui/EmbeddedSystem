# Cortex-R4 移植笔记

本周主要是进行一款 Cortex-R 芯片的移植工作，该芯片有如下特点：

- 属于 Cortex-R 内核
- 芯片默认运行于大端模式
- 有 3M flash 和 256K ram
- R4 内核的寄存器组看起来与 Cortex-A 系列一致，同样拥有多种运行时状态和相应的 bank 寄存器组
- 中断系统与先前接触的 STM32 NVIC 和 ZYNQ 的 GIC 都不同，使用的是一种 VIM（Vectored Interrupt Manager (VIM) Module ） 的中断管理器，支持硬件中断跳转（系统提供的一种快速中断响应方式）和软件查表跳转两种方式，其中软件查表方式和我们先前在 Cortex-A 系列中中断的处理方式相似

### 大端系统的处理

在先前接触到的大部分 CPU，都基于 arm 内核，大多都运行在小端模式，很少遇到运行于大端模式的 CPU，而目前 RTT 中的移植代码，大部分也默认按照小端模式来处理。由于本次移植需要处理的是大端模式的 CPU，因此在移植的过程中遇到了一些奇怪的现象。

在 RTT 操作系统中，当需要进行第一次线程切换前，需要将系统切换到 SVC 模式，然后执行如下代码：

```asm
    LDMIA   sp!, {r4}           ; pop new task cpsr to spsr
    MSR     spsr_cxsf, r4
    ; pop new task r0-r12, lr & pc, copy spsr to cpsr
    LDMIA   sp!, {r0-r12, lr, pc}^ 
```

这段代码将会从目标线程的栈中读出 CPSR 的值，存入到 SPSR 寄存器中，然后跳转到目标线程的执行代码中运行，跳转的过程中，最后一条命令会自动拷贝 SPSR 的值到目标线程环境下的 CPSR 寄存器中，而 CPSR 寄存器中保存着 CPU 的各种运行状态，这其中也包括了 CPU 是以大端模式还是以小端模式读取数据。

在 RTT 先前的 Cortex-A 系列的移植中，默认都配置成了小端模式，而这次，CPU 运行在大端模式下，一旦 CPU 的大小端模式被改变，很快就会出现莫名其妙的内存访问错误，原因是 CPU 会以小端数据的解析方式来解析大端数据。

### SYSTEM 模式不会出错

在处理该问题的过程中还有另外一个现象，那就是如果在跳转前不切换到 SVC 模式，系统就不会崩溃，此时系统处于 SYSTEM 模式，该模式是调用该芯片的 HAL 库进行系统初始化后默认的状态。

造成这种情况的原因是，当系统处于 SYSTEM 模式下，这种状态没有 CPSR 和 SPSR 寄存器，如果进行访问操作，会出现未知状态，也就是说 `MSR     spsr_cxsf, r4` 这条指令是无效的，不会将相关的状态存入 SPSR 寄存器，系统也就不会切换到小端状态工作。

### 低中断延时技术

在 Cortex-R4 系列的技术手册中描述了一种低中断延时技术，描述如下：

```
Low Interrupt Latency (LIL) is a set of behaviors that reduce the interrupt latency for the processor, and is enabled by default. That is, the FI bit [21] in the SCTLR is Read-as-One.

LIL behavior enables accesses to Normal memory, including multiword accesses and external accesses, to be abandoned part-way through execution so that the processor can react to a pending interrupt faster than would otherwise be the case. When an instruction is abandoned in this way, the processor behaves as if the instruction was not executed at all. 

If, after handling the interrupt, the interrupt handler returns to the program in the normal way using instruction SUBS pc, r14, #4, the abandoned instruction is re-executed. This means that some of the memory accesses generated by the instruction are performed twice. 

Memory that is marked as Strongly-ordered or Device type is typically sensitive to the number of reads or writes performed. Because of this, instructions that access Strongly-ordered or Device memory are never abandoned when they have started accessing memory. These instructions always complete either all or none of their memory accesses. 

Therefore, to minimize the interrupt latency, you must avoid the use of multiword load/store instructions to memory locations that are marked as Strongly-ordered or Device. 
```

从上述描述可知，在 Cortex-R 系列中，默认开启了低延时中断技术，使得在使用多字节内存访问指令时在中间过程中可以被中断。

例如：

```asm
VSTMDB  sp!, {d0-d15}     # 使用 VSTM 指令一次操作向栈中压入多个数据 
LDMIA   sp!, {r0-r12,lr}  # 使用 LDM 指令一次向寄存器中加载多个数据
```

在这些指令的执行过程中，如果开启了 Low Interrupt Latency (LIL)  功能，则该过程可能被打断。等到中断处理函数执行完毕返回时，被中断指令（例如 VSTMDB） 将会被再次执行，这就意味着被该指令执行的内存访问操作可能会被执行两次。

如果访问的内存是普通内存，那么被访问两次可能也没有太大问题，但是如果访问的是强序内存或者设备内存，那么对内存的多次访问读写会造成副作用。因此，对于强序内存和设备内存来说，访问操作要么不开始，要么就要完全执行完毕，而不能被中途打断。

如果使用了多数据操作指令访问强序内存或者设备内存，因为该操作指令不能被中断，所以中断触发就要等到内存访问执行执行完毕，而访存操作速度是很慢的，也因此增大了中断响应时间。

所以需要避免使用 multiword load/store instructions 操作强序内存或设备内存，使得中断延时时间最小化。

